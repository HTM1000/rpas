# -*- coding: utf-8 -*-
"""
validador_hibrido.py
====================
Sistema de valida√ß√£o h√≠brido para campos Oracle (substitui valida√ß√£o OCR).

Combina 3 t√©cnicas para m√°xima confiabilidade:
1. An√°lise de Pixels - Detecta se campo est√° vazio ou preenchido
2. Clipboard - L√™ valor exato do campo (Ctrl+A + Ctrl+C)
3. Detec√ß√£o de Erros - Verifica imagens de erro (qtd_negativa, ErroProduto)

Vantagens sobre OCR:
- N√£o sofre com erros de reconhecimento (E vs &, 0 vs O, etc)
- L√™ valor exato do campo sem ambiguidade
- Mais r√°pido que OCR complexo
- Combina verifica√ß√£o estrutural + sem√¢ntica

Autor: Claude Code
Data: 2025-10-24
"""

import time
import pyautogui
import pyperclip
import numpy as np
from PIL import Image, ImageGrab
import os
import sys

# ============================================================================
# CONFIGURA√á√ïES
# ============================================================================

# Threshold de pixels n√£o-brancos para considerar campo preenchido
# IMPORTANTE: 2% estava pegando bordas/sombras como texto! Aumentado para 5%
THRESHOLD_PIXELS = 0.05  # 5% dos pixels devem ser n√£o-brancos (mais rigoroso)

# Valor RGB considerado "branco" (pixels acima disso = vazios)
# IMPORTANTE: 240 pode estar deixando passar cinzas claros. Reduzido para 230
THRESHOLD_BRANCO = 230

# Delays para opera√ß√µes de clipboard (ms)
DELAY_CLIPBOARD_CLICK = 200
DELAY_CLIPBOARD_SELECT = 100
DELAY_CLIPBOARD_COPY = 200

# ============================================================================
# FUN√á√ïES AUXILIARES
# ============================================================================

def gui_log(mensagem):
    """Log compat√≠vel com GUI (pode ser substitu√≠do externamente)"""
    print(mensagem)


def carregar_imagem_erro(nome_arquivo):
    """
    Carrega imagem de erro (compat√≠vel com .exe e script Python).

    Args:
        nome_arquivo: Nome do arquivo (ex: "qtd_negativa.png")

    Returns:
        str: Caminho completo da imagem ou None se n√£o encontrado
    """
    if getattr(sys, 'frozen', False):
        # Execut√°vel: busca em _internal/informacoes/
        base_path = os.path.join(sys._MEIPASS, 'informacoes')
    else:
        # Script Python: busca em informacoes/
        base_path = os.path.join(os.path.dirname(__file__), 'informacoes')

    caminho = os.path.join(base_path, nome_arquivo)

    if os.path.exists(caminho):
        return caminho
    else:
        gui_log(f"‚ö†Ô∏è [VALIDADOR] Imagem n√£o encontrada: {caminho}")
        return None


# ============================================================================
# ETAPA 1: VALIDA√á√ÉO POR AN√ÅLISE DE PIXELS
# ============================================================================

def validar_campo_preenchido(x, y, largura, altura, threshold=THRESHOLD_PIXELS):
    """
    Verifica se campo tem texto analisando densidade de pixels n√£o-brancos.

    T√©cnica: Captura regi√£o do campo, converte para escala de cinza,
    conta quantos pixels s√£o "escuros" (< 240). Se > threshold%, campo est√° preenchido.

    Args:
        x, y: Coordenadas do canto superior esquerdo
        largura, altura: Dimens√µes do campo
        threshold: % m√≠nimo de pixels n√£o-brancos para considerar preenchido

    Returns:
        tuple: (campo_preenchido: bool, percentual: float, detalhes: dict)
    """
    try:
        # Capturar campo
        img = ImageGrab.grab(bbox=(x, y, x + largura, y + altura))

        # Converter para escala de cinza
        img_gray = img.convert('L')
        img_array = np.array(img_gray)

        # Contar pixels n√£o-brancos (texto/caracteres)
        pixels_nao_brancos = np.sum(img_array < THRESHOLD_BRANCO)
        total_pixels = img_array.size
        percentual = pixels_nao_brancos / total_pixels

        campo_preenchido = percentual > threshold

        detalhes = {
            "total_pixels": total_pixels,
            "pixels_nao_brancos": pixels_nao_brancos,
            "percentual": percentual,
            "threshold": threshold
        }

        return campo_preenchido, percentual, detalhes

    except Exception as e:
        gui_log(f"‚ö†Ô∏è [PIXELS] Erro ao analisar pixels: {e}")
        return False, 0.0, {"erro": str(e)}


# ============================================================================
# ETAPA 2: VALIDA√á√ÉO POR CLIPBOARD
# ============================================================================

def ler_campo_via_clipboard(x, y, timeout=1.0, tentar_triplo_clique=True):
    """
    L√™ conte√∫do exato do campo copiando para clipboard (Ctrl+A + Ctrl+C).

    T√©cnica:
    1. Salva clipboard atual
    2. Clica no campo
    3. Seleciona tudo (Ctrl+A OU triplo-clique para campos num√©ricos)
    4. Copia (Ctrl+C)
    5. L√™ clipboard
    6. Restaura clipboard original

    Args:
        x, y: Coordenadas do campo
        timeout: Tempo m√°ximo de espera (segundos)
        tentar_triplo_clique: Se True, tenta triplo-clique antes de Ctrl+A (melhor para n√∫meros)

    Returns:
        str: Conte√∫do do campo ou "" se erro
    """
    clipboard_backup = ""

    try:
        # üîß CORRE√á√ÉO: Verificar se RPA est√° rodando antes de iniciar
        # Importar dinamicamente para evitar depend√™ncia circular
        try:
            import main_ciclo
            if not main_ciclo._rpa_running:
                gui_log("   ‚ö†Ô∏è [CLIPBOARD] RPA parado, abortando leitura")
                return ""
        except:
            pass  # Se n√£o conseguir importar, continua normalmente

        # Salvar clipboard atual
        clipboard_backup = pyperclip.paste()

        # Limpar clipboard
        pyperclip.copy("")

        # Clicar no campo
        pyautogui.click(x, y)
        time.sleep(DELAY_CLIPBOARD_CLICK / 1000.0)

        # üîß CORRE√á√ÉO: Tentar TRIPLO-CLIQUE primeiro (melhor para campos alinhados √† direita)
        # Triplo-clique seleciona todo o conte√∫do sem espa√ßos extras
        valor = ""

        if tentar_triplo_clique:
            try:
                # Triplo-clique para selecionar tudo
                pyautogui.click(x, y, clicks=3, interval=0.05)
                time.sleep(DELAY_CLIPBOARD_SELECT / 1000.0)

                # Copiar
                pyautogui.hotkey('ctrl', 'c')
                time.sleep(DELAY_CLIPBOARD_COPY / 1000.0)

                # Ler clipboard
                valor = pyperclip.paste().strip()

                # Se conseguiu ler algo, retorna
                if valor:
                    gui_log(f"   üìã [TRIPLO-CLIQUE] Lido: '{valor}'")
                    return valor
            except:
                pass

        # Fallback: Usar Ctrl+A (m√©todo original)
        # üîß Verificar novamente se RPA foi parado
        try:
            import main_ciclo
            if not main_ciclo._rpa_running:
                gui_log("   ‚ö†Ô∏è [CLIPBOARD] RPA parado durante fallback")
                return ""
        except:
            pass

        pyperclip.copy("")  # Limpar novamente
        pyautogui.click(x, y)  # Clicar novamente
        time.sleep(DELAY_CLIPBOARD_CLICK / 1000.0)

        # Selecionar tudo
        pyautogui.hotkey('ctrl', 'a')
        time.sleep(DELAY_CLIPBOARD_SELECT / 1000.0)

        # Copiar
        pyautogui.hotkey('ctrl', 'c')
        time.sleep(DELAY_CLIPBOARD_COPY / 1000.0)

        # Ler clipboard
        valor = pyperclip.paste().strip()
        gui_log(f"   üìã [CTRL+A] Lido: '{valor}'")

        return valor

    except Exception as e:
        gui_log(f"‚ö†Ô∏è [CLIPBOARD] Erro ao ler campo: {e}")
        return ""

    finally:
        # Restaurar clipboard (com prote√ß√£o contra erro)
        try:
            pyperclip.copy(clipboard_backup)
        except:
            pass


def validar_campo_clipboard(x, y, valor_esperado, nome_campo="Campo", normalizar=True):
    """
    Valida campo Oracle comparando valor via clipboard.

    Args:
        x, y: Coordenadas do campo
        valor_esperado: Valor que deveria estar no campo
        nome_campo: Nome do campo (para logs)
        normalizar: Se True, remove espa√ßos e converte para mai√∫sculas

    Returns:
        tuple: (sucesso: bool, valor_lido: str, detalhes: dict)
    """
    try:
        # Ler valor do campo
        valor_lido = ler_campo_via_clipboard(x, y)

        if normalizar:
            # Normalizar valores (mai√∫sculas, sem espa√ßos)
            valor_lido_norm = valor_lido.upper().strip().replace(" ", "")
            valor_esperado_norm = str(valor_esperado).upper().strip().replace(" ", "")
        else:
            valor_lido_norm = valor_lido.strip()
            valor_esperado_norm = str(valor_esperado).strip()

        # üîß CORRE√á√ÉO: Para campos num√©ricos (quantidade, etc), fazer compara√ß√£o num√©rica
        # Isso resolve problemas com alinhamento √† direita e formata√ß√£o diferente
        eh_campo_quantidade = "QUANT" in nome_campo.upper() or nome_campo.upper() == "QUANTIDADE"

        if eh_campo_quantidade:
            try:
                # Tentar converter ambos para n√∫meros para compara√ß√£o
                # Remove v√≠rgulas, pontos de milhar, etc
                valor_lido_num = valor_lido_norm.replace(",", "").replace(".", "")
                valor_esperado_num = str(valor_esperado_norm).replace(",", "").replace(".", "")

                # Comparar como n√∫meros
                if valor_lido_num.isdigit() and valor_esperado_num.isdigit():
                    sucesso = int(valor_lido_num) == int(valor_esperado_num)
                    gui_log(f"   üî¢ [NUM√âRICO] Compara√ß√£o: {int(valor_lido_num)} == {int(valor_esperado_num)} ‚Üí {sucesso}")
                else:
                    # Fallback: compara√ß√£o de string
                    sucesso = valor_lido_norm == valor_esperado_norm
                    gui_log(f"   üìù [STRING] Compara√ß√£o: '{valor_lido_norm}' == '{valor_esperado_norm}' ‚Üí {sucesso}")
            except:
                # Se convers√£o falhar, usa compara√ß√£o de string padr√£o
                sucesso = valor_lido_norm == valor_esperado_norm
                gui_log(f"   ‚ö†Ô∏è [FALLBACK] Compara√ß√£o string: '{valor_lido_norm}' == '{valor_esperado_norm}' ‚Üí {sucesso}")
        else:
            sucesso = valor_lido_norm == valor_esperado_norm

        detalhes = {
            "valor_lido": valor_lido,
            "valor_esperado": valor_esperado,
            "valor_lido_norm": valor_lido_norm,
            "valor_esperado_norm": valor_esperado_norm,
            "normalizado": normalizar,
            "eh_campo_quantidade": eh_campo_quantidade
        }

        return sucesso, valor_lido, detalhes

    except Exception as e:
        gui_log(f"‚ö†Ô∏è [CLIPBOARD] Erro na valida√ß√£o: {e}")
        return False, "", {"erro": str(e)}


# ============================================================================
# ETAPA 3: DETEC√á√ÉO DE ERROS VISUAIS
# ============================================================================

def detectar_erro_oracle(confidence=0.7):
    """
    Detecta erros visuais do Oracle usando template matching.

    Verifica se aparecem as imagens de erro conhecidas:
    - qtd_negativa.png: Erro de quantidade negativa
    - ErroProduto.png: Produto inv√°lido/n√£o encontrado

    Args:
        confidence: Confian√ßa m√≠nima para considerar match (0.0-1.0)

    Returns:
        tuple: (erro_detectado: bool, tipo_erro: str, posicao: tuple ou None)
    """
    try:
        # Verificar qtd_negativa.png
        img_qtd_negativa = carregar_imagem_erro("qtd_negativa.png")
        if img_qtd_negativa:
            try:
                pos_qtd = pyautogui.locateOnScreen(img_qtd_negativa, confidence=confidence)
                if pos_qtd:
                    gui_log(f"üõë [ERRO] Quantidade negativa detectada em {pos_qtd}")
                    return True, "QTD_NEGATIVA", pos_qtd
            except pyautogui.ImageNotFoundException:
                pass

        # Verificar ErroProduto.png
        img_erro_produto = carregar_imagem_erro("ErroProduto.png")
        if img_erro_produto:
            try:
                pos_erro = pyautogui.locateOnScreen(img_erro_produto, confidence=confidence)
                if pos_erro:
                    gui_log(f"üõë [ERRO] Produto inv√°lido detectado em {pos_erro}")
                    return True, "PRODUTO_INVALIDO", pos_erro
            except pyautogui.ImageNotFoundException:
                pass

        # Nenhum erro detectado
        return False, "", None

    except Exception as e:
        gui_log(f"‚ö†Ô∏è [DETEC√á√ÉO] Erro ao verificar imagens: {e}")
        return False, "ERRO_DETECCAO", None


# ============================================================================
# VALIDA√á√ÉO H√çBRIDA PRINCIPAL
# ============================================================================

def validar_campo_oracle_hibrido(
    x, y, largura, altura,
    valor_esperado,
    nome_campo="Campo",
    validar_conteudo=True,
    verificar_erros=True
):
    """
    Valida√ß√£o h√≠brida usando CLIPBOARD como m√©todo principal.

    ETAPA 1: Clipboard (Ctrl+C) - Verifica se campo tem conte√∫do
    ETAPA 2: Detec√ß√£o de Erros (imagens de erro) - OPCIONAL

    Args:
        x, y: Coordenadas do canto superior esquerdo do campo
        largura, altura: Dimens√µes do campo
        valor_esperado: Valor que deveria estar no campo
        nome_campo: Nome do campo (para logs)
        validar_conteudo: Se True, compara valor | Se False, s√≥ verifica se preenchido
        verificar_erros: Se True, verifica imagens de erro (Etapa 3)

    Returns:
        tuple: (sucesso: bool, tipo_resultado: str, detalhes: dict)

        Tipos de resultado:
        - "OK": Valida√ß√£o passou em todas as etapas
        - "CAMPO_VAZIO": Campo n√£o tem conte√∫do (clipboard vazio)
        - "VALOR_ERRADO": Valor diverge do esperado
        - "QTD_NEGATIVA": Erro Oracle de quantidade negativa
        - "PRODUTO_INVALIDO": Erro Oracle de produto inv√°lido
        - "ERRO_VALIDACAO": Erro durante valida√ß√£o
    """
    detalhes = {
        "campo": nome_campo,
        "coordenadas": (x, y, largura, altura),
        "valor_esperado": valor_esperado,
        "etapas": {}
    }

    gui_log(f"üîç [H√çBRIDO] Iniciando valida√ß√£o: {nome_campo}")
    gui_log(f"   üìç Posi√ß√£o: ({x}, {y}) | Tamanho: {largura}x{altura}")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # ETAPA 1: Ler campo via Clipboard (Ctrl+C)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    gui_log(f"   [1/2] Lendo campo via clipboard (Ctrl+C)...")

    # Calcular centro do campo para clicar
    centro_x = x + largura // 2
    centro_y = y + altura // 2

    # Ler valor do campo
    valor_lido = ler_campo_via_clipboard(centro_x, centro_y)

    # Verificar se campo est√° vazio
    if not valor_lido or valor_lido.strip() == "":
        gui_log(f"   ‚ùå Campo VAZIO! Clipboard retornou: '{valor_lido}'")
        detalhes["etapas"]["clipboard"] = {
            "valor_lido": valor_lido,
            "campo_vazio": True
        }
        return False, "CAMPO_VAZIO", detalhes

    gui_log(f"   ‚úÖ Campo PREENCHIDO! Valor lido: '{valor_lido}'")

    # Se validar_conteudo=True, compara valores
    if validar_conteudo:
        gui_log(f"   [1.1] Comparando valor lido com esperado...")

        # Normalizar valores
        valor_lido_norm = valor_lido.upper().strip().replace(" ", "")
        valor_esperado_norm = str(valor_esperado).upper().strip().replace(" ", "")

        # Verificar se √© campo num√©rico
        eh_campo_quantidade = "QUANT" in nome_campo.upper()

        if eh_campo_quantidade:
            try:
                valor_lido_num = valor_lido_norm.replace(",", "").replace(".", "")
                valor_esperado_num = str(valor_esperado_norm).replace(",", "").replace(".", "")

                if valor_lido_num.isdigit() and valor_esperado_num.isdigit():
                    sucesso = int(valor_lido_num) == int(valor_esperado_num)
                    gui_log(f"      üî¢ [NUM√âRICO] {int(valor_lido_num)} == {int(valor_esperado_num)} ‚Üí {sucesso}")
                else:
                    sucesso = valor_lido_norm == valor_esperado_norm
                    gui_log(f"      üìù [STRING] '{valor_lido_norm}' == '{valor_esperado_norm}' ‚Üí {sucesso}")
            except:
                sucesso = valor_lido_norm == valor_esperado_norm
        else:
            sucesso = valor_lido_norm == valor_esperado_norm
            gui_log(f"      üìù '{valor_lido_norm}' == '{valor_esperado_norm}' ‚Üí {sucesso}")

        detalhes["etapas"]["clipboard"] = {
            "valor_lido": valor_lido,
            "valor_esperado": valor_esperado,
            "valor_lido_norm": valor_lido_norm,
            "valor_esperado_norm": valor_esperado_norm,
            "sucesso": sucesso
        }

        if not sucesso:
            gui_log(f"   ‚ùå VALORES DIFERENTES!")
            return False, "VALOR_ERRADO", detalhes

        gui_log(f"   ‚úÖ Valores correspondem!")
    else:
        gui_log(f"   [1.1] Valida√ß√£o de conte√∫do desabilitada - qualquer valor aceito")
        detalhes["etapas"]["clipboard"] = {
            "valor_lido": valor_lido,
            "campo_vazio": False,
            "validacao_conteudo": False
        }

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # ETAPA 2: Erro Oracle? (Detec√ß√£o Visual) - OPCIONAL
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if verificar_erros:
        gui_log(f"   [2/2] Verificando erros Oracle...")

        erro_detectado, tipo_erro, posicao = detectar_erro_oracle()
        detalhes["etapas"]["deteccao_erros"] = {
            "erro_detectado": erro_detectado,
            "tipo_erro": tipo_erro,
            "posicao": posicao
        }

        if erro_detectado:
            gui_log(f"   üõë ERRO ORACLE: {tipo_erro}")
            return False, tipo_erro, detalhes

        gui_log(f"   ‚úÖ Sem erros detectados")
    else:
        gui_log(f"   [2/2] Pulando detec√ß√£o de erros (verificar_erros=False)")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # SUCESSO!
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    gui_log(f"   ‚úÖ‚úÖ [{nome_campo}] Valida√ß√£o completa OK!")
    return True, "OK", detalhes


def validar_campos_oracle_completo(coords, item, quantidade, referencia, sub_o, end_o, sub_d, end_d):
    """
    Valida todos os campos do formul√°rio Oracle de uma vez.

    Substitui a fun√ß√£o validar_campos_oracle_ocr() do main_ciclo.py.

    Args:
        coords: Dicion√°rio com coordenadas dos campos (do config.json)
        item, quantidade, referencia, sub_o, end_o, sub_d, end_d: Valores esperados

    Returns:
        tuple: (validacao_ok: bool, tipo_erro: str)
    """
    gui_log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    gui_log("üîç [VALIDA√á√ÉO H√çBRIDA] Iniciando valida√ß√£o completa")
    gui_log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

    # üìä MOSTRAR VALORES ESPERADOS DA PLANILHA
    gui_log("")
    gui_log("üìä VALORES ESPERADOS (da planilha Google Sheets):")
    gui_log(f"   Item: '{item}'")
    gui_log(f"   Quantidade: '{quantidade}'")
    gui_log(f"   Refer√™ncia: '{referencia}'")
    gui_log(f"   Subinvent. (origem): '{sub_o}'")
    gui_log(f"   Endere√ßo (origem): '{end_o}'")
    gui_log(f"   Para Subinv. (destino): '{sub_d}'")
    gui_log(f"   Para Loc. (destino): '{end_d}'")
    gui_log("")

    # Detectar tipo de refer√™ncia
    eh_cod = referencia and str(referencia).upper().strip().startswith("COD")

    if eh_cod:
        gui_log("üìã Refer√™ncia COD detectada - validando campos DESTINO")
        gui_log("   ‚öôÔ∏è REGRA: Apenas verificar se campos est√£o PREENCHIDOS (valores n√£o importam)")

        # Para COD: apenas verificar se campos est√£o preenchidos
        campos_validar = [
            ("Item", coords["campo_item"], item),
            ("Quantidade", coords["campo_quantidade"], quantidade),
            ("Refer√™ncia", coords["campo_referencia"], referencia),
            ("Para Subinv.", coords["campo_sub_d"], sub_d),
            ("Para Loc.", coords["campo_end_d"], end_d),
        ]
    else:
        gui_log("üìã Refer√™ncia MOV/OUTRO - validando campos ORIGEM")
        gui_log("   ‚öôÔ∏è REGRA: Apenas verificar se campos est√£o PREENCHIDOS (valores n√£o importam)")

        # Para MOV/OUTRO: apenas verificar se campos est√£o preenchidos
        campos_validar = [
            ("Item", coords["campo_item"], item),
            ("Quantidade", coords["campo_quantidade"], quantidade),
            ("Refer√™ncia", coords["campo_referencia"], referencia),
            ("Subinvent.", coords["campo_sub_o"], sub_o),
            ("Endere√ßo", coords["campo_end_o"], end_o),
        ]

    gui_log("")
    gui_log("‚îÄ" * 60)
    gui_log("üîé INICIANDO VALIDA√á√ÉO CAMPO POR CAMPO:")
    gui_log("‚îÄ" * 60)

    # Validar cada campo
    erros = []
    erros_detalhados = []
    campos_validados_ok = []

    for idx, (nome, coord, valor) in enumerate(campos_validar, 1):
        # üîß CORRE√á√ÉO: Verificar se RPA foi parado
        try:
            import main_ciclo
            if not main_ciclo._rpa_running:
                gui_log("üõë RPA PARADO - Interrompendo valida√ß√£o")
                return False, "RPA_PARADO"
        except:
            pass

        x, y, largura, altura = coord

        gui_log("")
        gui_log(f"‚îÅ‚îÅ‚îÅ [{idx}/{len(campos_validar)}] CAMPO: {nome} ‚îÅ‚îÅ‚îÅ")
        gui_log(f"üìù Valor da planilha: '{valor}' (apenas para refer√™ncia)")
        gui_log(f"üîç Verificando se campo est√° PREENCHIDO (valor n√£o ser√° comparado)")
        gui_log(f"üìç Coordenadas: ({x}, {y}) | Tamanho: {largura}x{altura}")

        sucesso, tipo, detalhes = validar_campo_oracle_hibrido(
            x, y, largura, altura,
            valor_esperado=valor,
            nome_campo=nome,
            validar_conteudo=False,  # False = N√ÉO comparar valor, apenas verificar se preenchido
            verificar_erros=False   # Verificar erros globais depois
        )

        if not sucesso:
            # Extrair informa√ß√µes detalhadas do erro
            if tipo == "CAMPO_VAZIO":
                clipboard_info = detalhes.get("etapas", {}).get("clipboard", {})
                valor_clipboard = clipboard_info.get("valor_lido", "")

                gui_log(f"‚ùå ERRO: Campo est√° VAZIO!")
                gui_log(f"   üìã Clipboard retornou: '{valor_clipboard}'")
                gui_log(f"   ‚ö†Ô∏è Campo obrigat√≥rio n√£o foi preenchido")
                erro_detalhado = f"{nome}: CAMPO_VAZIO (clipboard: '{valor_clipboard}')"
            else:
                gui_log(f"‚ùå ERRO: {tipo}")
                erro_detalhado = f"{nome}: {tipo}"

            erros.append(f"{nome} ({tipo})")
            erros_detalhados.append(erro_detalhado)
        else:
            # Campo est√° preenchido - mostrar valor lido do clipboard
            clipboard_info = detalhes.get("etapas", {}).get("clipboard", {})
            valor_lido = clipboard_info.get("valor_lido", "???")

            gui_log(f"‚úÖ SUCESSO: Campo PREENCHIDO")
            gui_log(f"   üìã Valor lido do clipboard: '{valor_lido}'")

            campos_validados_ok.append(nome)

    gui_log("")
    gui_log("‚îÄ" * 60)
    gui_log("üìä RESUMO DA VALIDA√á√ÉO:")
    gui_log("‚îÄ" * 60)

    # Log dos campos validados com sucesso
    if campos_validados_ok:
        gui_log(f"‚úÖ Campos validados OK ({len(campos_validados_ok)}):")
        for campo in campos_validados_ok:
            gui_log(f"   ‚Ä¢ {campo}")

    # Verificar erros globais Oracle
    gui_log("")
    gui_log("üîç Verificando erros visuais do Oracle...")
    erro_detectado, tipo_erro, _ = detectar_erro_oracle()

    if erro_detectado:
        gui_log(f"üõë ERRO ORACLE GLOBAL: {tipo_erro}")
        gui_log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        return False, tipo_erro

    gui_log("‚úÖ Sem erros visuais detectados")

    # Retornar resultado
    if erros:
        gui_log("")
        gui_log(f"‚ùå VALIDA√á√ÉO FALHOU! {len(erros)} campo(s) com erro:")
        for idx, erro_det in enumerate(erros_detalhados, 1):
            gui_log(f"{idx}. {erro_det}")

        # Criar tipo de erro resumido
        tipo_erro_resumido = " + ".join(erros[:3])  # M√°ximo 3 campos no resumo
        if len(erros) > 3:
            tipo_erro_resumido += f" (+{len(erros)-3} outros)"

        gui_log("")
        gui_log("üßπ Formul√°rio ser√° LIMPO com F6 para reprocessamento")
        gui_log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        return False, tipo_erro_resumido

    gui_log("")
    gui_log("‚úÖ‚úÖ‚úÖ TODOS OS CAMPOS VALIDADOS COM SUCESSO!")
    gui_log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    return True, ""


# ============================================================================
# MODO DE TESTE
# ============================================================================

if __name__ == "__main__":
    """
    Teste standalone do validador h√≠brido.

    Uso:
        python validador_hibrido.py
    """
    print("=" * 60)
    print("TESTE DO VALIDADOR H√çBRIDO")
    print("=" * 60)

    # Teste de an√°lise de pixels
    print("\n1. Teste de An√°lise de Pixels")
    print("   Clique em um campo do Oracle em 3 segundos...")
    time.sleep(3)

    # Capturar posi√ß√£o do mouse
    x, y = pyautogui.position()
    print(f"   Posi√ß√£o capturada: ({x}, {y})")

    # Validar campo (exemplo: 200x30 pixels)
    preenchido, percentual, detalhes = validar_campo_preenchido(x-100, y-15, 200, 30)
    print(f"   Campo preenchido: {preenchido}")
    print(f"   Percentual pixels: {percentual:.2%}")
    print(f"   Detalhes: {detalhes}")

    # Teste de clipboard
    print("\n2. Teste de Clipboard")
    print("   Clique em um campo com texto em 3 segundos...")
    time.sleep(3)

    x, y = pyautogui.position()
    valor = ler_campo_via_clipboard(x, y)
    print(f"   Valor lido: '{valor}'")

    # Teste de detec√ß√£o de erros
    print("\n3. Teste de Detec√ß√£o de Erros")
    erro, tipo, pos = detectar_erro_oracle()
    print(f"   Erro detectado: {erro}")
    print(f"   Tipo: {tipo}")
    print(f"   Posi√ß√£o: {pos}")

    print("\n" + "=" * 60)
    print("TESTES CONCLU√çDOS")
    print("=" * 60)
